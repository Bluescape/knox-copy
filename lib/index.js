// Generated by CoffeeScript 1.3.3
(function() {
  var Parser, ensureBuffer, guzzle, isArray, knox, qs, queue, stripLeadingSlash, swapPrefix, waterfall, _ref;

  qs = require('querystring');

  isArray = require('util').isArray;

  _ref = require('async'), queue = _ref.queue, waterfall = _ref.waterfall;

  knox = require('knox');

  Parser = require('xml2js').Parser;

  stripLeadingSlash = function(key) {
    return key.replace(/^\//, '');
  };

  swapPrefix = function(key, oldPre, newPre) {
    return "" + newPre + "/" + (stripLeadingSlash(key.slice(oldPre.length)));
  };

  ensureBuffer = function(data) {
    return Buffer.isBuffer(data) && data || new Buffer(data);
  };

  /*
  Read a whole stream into a buffer.
  */


  guzzle = function(stream, cb) {
    var buffers;
    buffers = [];
    stream.on('data', function(chunk) {
      return buffers.push(ensureBuffer(chunk));
    });
    stream.on('error', function(err) {
      return cb(err);
    });
    return stream.on('end', function() {
      return cb(null, Buffer.concat(buffers));
    });
  };

  /*
  Returns an http request.  Optional callback receives the response.
  */


  knox.prototype.copyFromBucket = function(fromBucket, fromKey, toKey, headers, cb) {
    var req;
    if (typeof headers === 'function') {
      cb = headers;
      headers = {};
    }
    headers['x-amz-copy-source'] = "/" + fromBucket + "/" + (stripLeadingSlash(fromKey));
    headers['Content-Length'] = 0;
    req = this.request('PUT', toKey, headers);
    if (cb != null) {
      req.on('response', function(res) {
        return cb(null, res);
      });
      req.on('error', function(err) {
        return cb(new Error("Error copying " + fromKey + ":", err));
      });
      req.end();
    }
    return req;
  };

  /*
  Callback gets a JSON representation of the page of S3 Object keys.
  */


  knox.prototype.listBucketPage = function(_arg, cb) {
    var error, headers, marker, maxKeys, prefix,
      _this = this;
    maxKeys = _arg.maxKeys, marker = _arg.marker, prefix = _arg.prefix, headers = _arg.headers;
    if (maxKeys == null) {
      maxKeys = 1000;
    }
    if (headers == null) {
      headers = {};
    }
    if (prefix != null) {
      prefix = stripLeadingSlash(prefix);
    }
    if (marker != null) {
      marker = stripLeadingSlash(marker);
    }
    error = function(err) {
      return cb(new Error("Error listing bucket " + {
        marker: marker,
        prefix: prefix
      } + ":", err));
    };
    return waterfall([
      function(next) {
        var req;
        req = _this.request('GET', '/', headers);
        req.path += "?" + qs.stringify({
          'max-keys': maxKeys,
          prefix: prefix,
          marker: marker
        });
        req.on('error', error);
        req.on('response', function(res) {
          if (res.statusCode === 200) {
            return guzzle(res, next);
          } else {
            return error(res);
          }
        });
        return req.end();
      }, (new Parser({
        explicitArray: false,
        explicitRoot: false
      })).parseString, function(page, next) {
        page.IsTruncated = page.IsTruncated === 'true';
        page.Contents = isArray(page.Contents) ? page.Contents : page.Contents != null ? [page.Contents] : [];
        return next(null, page);
      }
    ], function(err, page) {
      if (err != null) {
        return error(err);
      } else {
        return cb(null, page);
      }
    });
  };

  knox.prototype.copyBucket = function(_arg, cb) {
    var concurrentRequests, count, failed, fatalError, fromBucket, fromClient, fromPrefix, keysExhausted, keysPending, keysRunningLow, marker, maxKeys, q, replenishKeys, toPrefix, worker,
      _this = this;
    fromBucket = _arg.fromBucket, fromPrefix = _arg.fromPrefix, toPrefix = _arg.toPrefix;
    if (fromBucket == null) {
      fromBucket = this.bucket;
    }
    fromClient = knox.createClient({
      key: this.key,
      secret: this.secret,
      bucket: fromBucket
    });
    fromPrefix = fromPrefix && stripLeadingSlash(fromPrefix) || '';
    toPrefix = toPrefix && stripLeadingSlash(toPrefix) || '';
    concurrentRequests = 5;
    maxKeys = 500;
    count = 0;
    keysPending = false;
    keysExhausted = false;
    keysRunningLow = function() {
      return q.length() < (maxKeys / 2);
    };
    marker = null;
    failed = false;
    fatalError = function(err) {
      failed = true;
      return cb(err, count);
    };
    replenishKeys = function(done) {
      if (done == null) {
        done = (function() {});
      }
      keysPending = true;
      return fromClient.listBucketPage({
        prefix: fromPrefix,
        maxKeys: maxKeys,
        marker: marker
      }, function(err, page) {
        var keys;
        if (err != null) {
          fatalError(err);
        }
        if (!failed) {
          keys = page.Contents.map(function(o) {
            return o.Key;
          });
          q.push(keys);
          if (page.IsTruncated) {
            marker = keys.slice(-1)[0];
          } else {
            keysExhausted = true;
          }
        }
        keysPending = false;
        return done(keys.length);
      });
    };
    worker = function(key, done) {
      var toKey;
      if (failed) {
        return done();
      }
      toKey = swapPrefix(key, fromPrefix, toPrefix);
      return _this.copyFromBucket(fromBucket, key, toKey, function(err, res) {
        if (err != null) {
          fatalError(err);
        }
        if (res.statusCode !== 200) {
          fatalError({
            key: key,
            statusCode: res.statusCode
          });
        }
        if (failed) {
          return done();
        }
        count++;
        if (!(keysExhausted || keysPending) && keysRunningLow()) {
          return replenishKeys(done);
        } else {
          return done();
        }
      });
    };
    q = queue(worker, concurrentRequests);
    replenishKeys(function(count) {
      if (!(count > 0)) {
        return cb(null, count);
      }
    });
    return q.drain = function() {
      if (!failed) {
        return cb(null, count);
      }
    };
  };

  module.exports = knox;

}).call(this);
